# Aggregate filtered data by month
monthly_crime_data <- filteredData() %>%
mutate(month = as.Date(format(date, "%Y-%m-01"))) %>% # Ensure 'month' is Date type for scale_x_date
group_by(month) %>%
summarise(crime_count = n(), .groups = 'drop') %>%
arrange(month)
date_range <- range(monthly_crime_data$month)
start_year <- year(min(date_range))
end_year <- year(max(date_range))
years_spanned <- as.numeric(difftime(max(date_range), min(date_range), units = "days")) / 365.25
# Decide date_breaks and date_labels based on the number of years spanned
if(years_spanned <= 3) {
date_breaks <- "1 month"
date_labels <- "%b %Y"
} else {
date_breaks <- "6 months"
date_labels <- "%b %Y"
}
year_starts <- seq(as.Date(paste0(start_year, "-01-01")),
as.Date(paste0(end_year, "-01-01")),
by = "1 year")
ggplot(monthly_crime_data, aes(x = month, y = crime_count, group = 1)) +
geom_line() +
geom_point() +
scale_x_date(date_breaks = date_breaks, date_labels = date_labels) +
geom_vline(xintercept = as.numeric(year_starts),
linetype = "dashed",
color = "grey") +
theme_minimal() +
xlab("Month") +
ylab("Number of Crimes") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
axis.text.y = element_text(size = 12),
axis.title = element_text(size = 14))
})
}
# Run the app
shinyApp(ui = ui, server = server)
View(raw_df)
View(geo_df)
library(tidyverse)
library(tidygeocoder)
library(readr)
library(stringr)
library(lubridate)
library(here)
library(scales)
options(scipen=999) # force full notation not scientific
start_time <- Sys.time()  # Capture start time
# Paths
raw_data_path <- here::here("data/crime_data_raw.csv")
geolocated_data_path <- here::here("data/crime_data_geolocated.csv")
# Read raw data
raw_df <- read_csv(raw_data_path) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on))
# Read geolocated data
if (file.exists(geolocated_data_path)) {
geo_df <- read_csv(geolocated_data_path) %>%
mutate(zip = as.character(zip))
} else {
# Initialize colnames and structure from raw data
geo_df <- read_csv(raw_data_path) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on)) %>%
slice(0)  # Select zero rows to keep just the column structure
write_csv(geo_df, geolocated_data_path)
}
# Geoprocessing
geoprocess_data <- function(raw_df, geo_df, geolocated_data_path) {
records_to_process <- anti_join(raw_df, geo_df, by = c("occurred_on", "100_block_addr", "zip"))
# Geocode the records to process
geo_processed <- records_to_process %>%
sample_n(2000, replace = FALSE) %>%  # Throttle for testing
tidygeocoder::geocode(
street = "100_block_addr",
postalcode = "zip",
state = "state",
method = "osm"
)
sec_remain <- nrow(records_to_process)
hr_remain <- sec_remain %/% 3600
min_remain <- (sec_remain %% 3600) %/% 60
cat("Processed", nrow(geo_processed), "records\n")
cat("There are", scales::comma(nrow(records_to_process)), "records remaining\n")
cat(sprintf("Estimated processing remaining: %02d hours and %02d minutes\n", hr_remain, min_remain))
# Write the geocoded data to file
write_csv(geo_processed, geolocated_data_path, append = T)
end_time <- Sys.time()  # Capture end time
duration_sec <- as.numeric(end_time - start_time, units = "secs")  # Calculate duration
hours <- duration_sec %/% 3600
minutes <- (duration_sec %% 3600) %/% 60
seconds <- duration_sec %% 60
formatted_duration <- sprintf("%02d:%02d:%02d", hours, minutes, round(seconds))
cat("Time elapsed:", formatted_duration, "h/m/s\n")
}
geoprocess_data(raw_df, geo_df, geolocated_data_path)
library(shiny)
library(bslib)
library(readr)
library(dplyr)
library(lubridate)
library(sf)
library(leaflet)
library(ggplot2)
library(here)
# Load and preprocess the data
geolocated_data_path <- here::here("data/crime_data_geolocated.csv")
# Assuming read_csv is from the readr package and it can handle this file path
geo_df <- read_csv(geolocated_data_path) %>%
mutate(zip = as.character(zip),
date = as.Date(occurred_on), # Correct column name for date
ucr_crime_category = as.character(ucr_crime_category),
lat = as.numeric(lat),  # Ensure lat is numeric
long = as.numeric(long)) %>%  # Ensure long is numeric
filter(!is.na(lat) & !is.na(long))
# Update UI definition
ui <- fluidPage(
theme = bslib::bs_theme(version = 5),
titlePanel("Crime Data Visualization"),
sidebarLayout(
sidebarPanel(
selectInput("yearSelect", "Select Year",
choices = c("All", as.character(2018:2024)), selected = "All", multiple = T),
sliderInput("dateRange", "Date",
min = min(geo_df$date, na.rm = TRUE),
max = max(geo_df$date, na.rm = TRUE),
value = range(geo_df$date, na.rm = TRUE),
timeFormat = "%Y-%m-%d",
step = 1,
dragRange = TRUE),
selectInput("crimeType", "Crime",
choices = unique(geo_df$ucr_crime_category),
multiple = TRUE,
selected = unique(geo_df$ucr_crime_category)),
actionButton("update", "Update"),
width = 3 # Set sidebar width to 3 columns
),
mainPanel(
leafletOutput("map"),
plotOutput("crimeGraph"), # Add a plot output for the crime graph
width = 9 # Set main panel width to 9 columns
)
)
)
# Update server logic
server <- function(input, output, session) {
# Create a reactive expression that updates only when the update button is clicked
filteredData <- eventReactive(input$update, {
geo_df %>%
filter(date >= input$dateRange[1] & date <= input$dateRange[2],
ucr_crime_category %in% input$crimeType)
})
# Automatically update the date slider when year selections change
observe({
if("All" %in% input$yearSelect) {
# If "All" is selected, reset the slider to the full date range
updateSliderInput(session, "dateRange",
value = range(geo_df$date, na.rm = TRUE))
} else {
# For specific year selections, calculate the min start date and max end date
years <- as.numeric(input$yearSelect)
startDate <- min(as.Date(paste0(years, "-01-01")))
endDate <- max(as.Date(paste0(years, "-12-31")))
updateSliderInput(session, "dateRange", value = c(startDate, endDate))
}
})
# Render the map output using the reactive expression for data
output$map <- renderLeaflet({
# Check if filteredData is not NULL to avoid errors before the button is first clicked
if (!is.null(filteredData())) {
leaflet(data = filteredData()) %>%
addTiles() %>%
addCircleMarkers(~long, ~lat,
color = "#333333", # Dark gray color
fillColor = "#333333", # Dark gray fill
fillOpacity = 0.2,
opacity = .2,
weight = 1,
popup = ~paste(ucr_crime_category, format(date, "%Y-%m-%d"), sep = "<br>"))
}
})
output$crimeGraph <- renderPlot({
# Aggregate filtered data by month
monthly_crime_data <- filteredData() %>%
mutate(month = as.Date(format(date, "%Y-%m-01"))) %>% # Ensure 'month' is Date type for scale_x_date
group_by(month) %>%
summarise(crime_count = n(), .groups = 'drop') %>%
arrange(month)
date_range <- range(monthly_crime_data$month)
start_year <- year(min(date_range))
end_year <- year(max(date_range))
years_spanned <- as.numeric(difftime(max(date_range), min(date_range), units = "days")) / 365.25
# Decide date_breaks and date_labels based on the number of years spanned
if(years_spanned <= 3) {
date_breaks <- "1 month"
date_labels <- "%b %Y"
} else {
date_breaks <- "6 months"
date_labels <- "%b %Y"
}
year_starts <- seq(as.Date(paste0(start_year, "-01-01")),
as.Date(paste0(end_year, "-01-01")),
by = "1 year")
ggplot(monthly_crime_data, aes(x = month, y = crime_count, group = 1)) +
geom_line() +
geom_point() +
scale_x_date(date_breaks = date_breaks, date_labels = date_labels) +
geom_vline(xintercept = as.numeric(year_starts),
linetype = "dashed",
color = "grey") +
theme_minimal() +
xlab("Month") +
ylab("Number of Crimes") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
axis.text.y = element_text(size = 12),
axis.title = element_text(size = 14))
})
}
# Run the app
shinyApp(ui = ui, server = server)
library(tidyverse)
library(tidygeocoder)
library(readr)
library(stringr)
library(lubridate)
library(here)
library(scales)
options(scipen=999) # force full notation not scientific
start_time <- Sys.time()  # Capture start time
# Paths
raw_data_path <- here::here("data/crime_data_raw.csv")
geolocated_data_path <- here::here("data/crime_data_geolocated.csv")
# Read raw data
raw_df <- read_csv(raw_data_path) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on))
# Read geolocated data
if (file.exists(geolocated_data_path)) {
geo_df <- read_csv(geolocated_data_path) %>%
mutate(zip = as.character(zip))
} else {
# Initialize colnames and structure from raw data
geo_df <- read_csv(raw_data_path) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on)) %>%
slice(0)  # Select zero rows to keep just the column structure
write_csv(geo_df, geolocated_data_path)
}
# Geoprocessing
geoprocess_data <- function(raw_df, geo_df, geolocated_data_path) {
records_to_process <- anti_join(raw_df, geo_df, by = c("occurred_on", "100_block_addr", "zip"))
# Geocode the records to process
geo_processed <- records_to_process %>%
sample_n(5000, replace = FALSE) %>%  # Throttle for testing
tidygeocoder::geocode(
street = "100_block_addr",
postalcode = "zip",
state = "state",
method = "osm"
)
sec_remain <- nrow(records_to_process)
hr_remain <- sec_remain %/% 3600
min_remain <- (sec_remain %% 3600) %/% 60
cat("Processed", nrow(geo_processed), "records\n")
cat("There are", scales::comma(nrow(records_to_process)), "records remaining\n")
cat(sprintf("Estimated processing remaining: %02d hours and %02d minutes\n", hr_remain, min_remain))
# Write the geocoded data to file
write_csv(geo_processed, geolocated_data_path, append = T)
end_time <- Sys.time()  # Capture end time
duration_sec <- as.numeric(end_time - start_time, units = "secs")  # Calculate duration
hours <- duration_sec %/% 3600
minutes <- (duration_sec %% 3600) %/% 60
seconds <- duration_sec %% 60
formatted_duration <- sprintf("%02d:%02d:%02d", hours, minutes, round(seconds))
cat("Time elapsed:", formatted_duration, "h/m/s\n")
}
geoprocess_data(raw_df, geo_df, geolocated_data_path)
View(geo_df)
View(geo_df)
library(shiny)
library(bslib)
library(readr)
library(dplyr)
library(lubridate)
library(sf)
library(leaflet)
library(ggplot2)
library(here)
# Load and preprocess the data
geolocated_data_path <- here::here("data/crime_data_geolocated.csv")
# Assuming read_csv is from the readr package and it can handle this file path
geo_df <- read_csv(geolocated_data_path) %>%
mutate(zip = as.character(zip),
date = as.Date(occurred_on), # Correct column name for date
ucr_crime_category = as.character(ucr_crime_category),
lat = as.numeric(lat),  # Ensure lat is numeric
long = as.numeric(long)) %>%  # Ensure long is numeric
filter(!is.na(lat) & !is.na(long))
# Update UI definition
ui <- fluidPage(
theme = bslib::bs_theme(version = 5),
titlePanel("Crime Data Visualization"),
sidebarLayout(
sidebarPanel(
selectInput("yearSelect", "Select Year",
choices = c("All", as.character(2018:2024)), selected = "All", multiple = T),
sliderInput("dateRange", "Date",
min = min(geo_df$date, na.rm = TRUE),
max = max(geo_df$date, na.rm = TRUE),
value = range(geo_df$date, na.rm = TRUE),
timeFormat = "%Y-%m-%d",
step = 1,
dragRange = TRUE),
selectInput("crimeType", "Crime",
choices = unique(geo_df$ucr_crime_category),
multiple = TRUE,
selected = unique(geo_df$ucr_crime_category)),
actionButton("update", "Update"),
width = 3 # Set sidebar width to 3 columns
),
mainPanel(
leafletOutput("map"),
plotOutput("crimeGraph"), # Add a plot output for the crime graph
width = 9 # Set main panel width to 9 columns
)
)
)
# Update server logic
server <- function(input, output, session) {
# Create a reactive expression that updates only when the update button is clicked
filteredData <- eventReactive(input$update, {
geo_df %>%
filter(date >= input$dateRange[1] & date <= input$dateRange[2],
ucr_crime_category %in% input$crimeType)
})
# Automatically update the date slider when year selections change
observe({
if("All" %in% input$yearSelect) {
# If "All" is selected, reset the slider to the full date range
updateSliderInput(session, "dateRange",
value = range(geo_df$date, na.rm = TRUE))
} else {
# For specific year selections, calculate the min start date and max end date
years <- as.numeric(input$yearSelect)
startDate <- min(as.Date(paste0(years, "-01-01")))
endDate <- max(as.Date(paste0(years, "-12-31")))
updateSliderInput(session, "dateRange", value = c(startDate, endDate))
}
})
# Render the map output using the reactive expression for data
output$map <- renderLeaflet({
# Check if filteredData is not NULL to avoid errors before the button is first clicked
if (!is.null(filteredData())) {
leaflet(data = filteredData()) %>%
addTiles() %>%
addCircleMarkers(~long, ~lat,
color = "#333333", # Dark gray color
fillColor = "#333333", # Dark gray fill
fillOpacity = 0.2,
opacity = .2,
weight = 1,
popup = ~paste(ucr_crime_category, format(date, "%Y-%m-%d"), sep = "<br>"))
}
})
output$crimeGraph <- renderPlot({
# Aggregate filtered data by month
monthly_crime_data <- filteredData() %>%
mutate(month = as.Date(format(date, "%Y-%m-01"))) %>% # Ensure 'month' is Date type for scale_x_date
group_by(month) %>%
summarise(crime_count = n(), .groups = 'drop') %>%
arrange(month)
date_range <- range(monthly_crime_data$month)
start_year <- year(min(date_range))
end_year <- year(max(date_range))
years_spanned <- as.numeric(difftime(max(date_range), min(date_range), units = "days")) / 365.25
# Decide date_breaks and date_labels based on the number of years spanned
if(years_spanned <= 3) {
date_breaks <- "1 month"
date_labels <- "%b %Y"
} else {
date_breaks <- "6 months"
date_labels <- "%b %Y"
}
year_starts <- seq(as.Date(paste0(start_year, "-01-01")),
as.Date(paste0(end_year, "-01-01")),
by = "1 year")
ggplot(monthly_crime_data, aes(x = month, y = crime_count, group = 1)) +
geom_line() +
geom_point() +
scale_x_date(date_breaks = date_breaks, date_labels = date_labels) +
geom_vline(xintercept = as.numeric(year_starts),
linetype = "dashed",
color = "grey") +
theme_minimal() +
xlab("Month") +
ylab("Number of Crimes") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
axis.text.y = element_text(size = 12),
axis.title = element_text(size = 14))
})
}
# Run the app
shinyApp(ui = ui, server = server)
View(raw_df)
# Step 1: Find the most recent date in the existing dataset
raw_data_path <- here::here("data/crime_data_raw.csv")
existing_data <- read_csv(raw_data_path)
existing_data <- read.csv(raw_data_path)
# Assuming "occurred_on" is in the format "YYYY-MM-DD"
# Convert "occurred_on" to Date type if it's not already
most_recent_date <- max(as.Date(existing_data$occurred_on), na.rm = TRUE)
as.Date(existing_data$occurred_on
as.Date(existing_data$occurred_on
as.Date(existing_data$occurred_on)
existing_data$occurred_on
View(existing_data)
# Step 1: Find the most recent date in the existing dataset
existing_data_path <- here::here("data/crime_data_raw.csv")
existing_data <- readr::read_csv(existing_data_path) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on))
library(readr)
library(dplyr)
library(here)
library(lubridate)
# Step 1: Find the most recent date in the existing dataset
existing_data_path <- here::here("data/crime_data_raw.csv")
existing_data <- readr::read_csv(existing_data_path) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on))
View(existing_data)
library(readr)
library(dplyr)
library(stringr)
library(here)
library(lubridate)
# Step 1: Find the most recent date in the existing dataset
existing_data_path <- here::here("data/crime_data_raw.csv")
existing_data <- readr::read_csv(existing_data_path) %>%
rename_with(~ str_to_lower(.) %>% stringr::str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on))
View(existing_data)
# Assuming "occurred_on" is in the format "YYYY-MM-DD"
# Convert "occurred_on" to Date type if it's not already
most_recent_date <- max(as.Date(existing_data$occurred_on), na.rm = TRUE)
# Step 2: Download the new dataset
url <- "https://www.phoenixopendata.com/dataset/cc08aace-9ca9-467f-b6c1-f0879ab1a358/resource/0ce3411a-2fc6-4302-a33f-167f68608a20/download/crime-data_crime-data_crimestat.csv"
new_data <- read_csv(url) %>%
rename_with(~ str_to_lower(.) %>% str_replace_all(" ", "_")) %>%
mutate(`100_block_addr` = str_replace_all(`100_block_addr`, "XX", "00"),
zip = as.character(zip),
state = "Arizona",
occurred_on = mdy_hm(occurred_on, truncated = 3),
occurred_to = mdy_hm(occurred_to, truncated = 3)) %>%
filter(!is.na(occurred_on))
View(new_data)
new_entries <- new_data %>%
mutate(date_filter <- as.Date(new_data$occurred_on)) %>%
filter(new_data, date_filter > most_recent_date)
new_entries <- new_data %>%
mutate(date_filter = as.Date(new_data$occurred_on)) %>%
filter(date_filter > most_recent_date)
View(new_entries)
new_entries <- new_data %>%
mutate(date_filter = as.Date(new_data$occurred_on)) %>%
filter(date_filter > most_recent_date) %>%
select(-date_filter)
View(new_entries)
# Step 4: Append new_entries to existing_data and save
if (nrow(new_entries) > 0) {
updated_data <- bind_rows(existing_data, new_entries)
write_csv(updated_data, existing_data_path)
cat("New entries added:", nrow(new_entries), "\n")
} else {
cat("No new entries to add. Dataset is up-to-date.\n")
}
